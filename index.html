<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>CS 498: Narrative visualization project</title>
    <style>
        @import url(//fonts.googleapis.com/css?family=Open+Sans:400,700);

        #svg-container {
            position: relative;
        }

        svg {
            font: 14px 'Open Sans';
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .axis text {
            fill: #000;
        }

        .axis .tick line {
            stroke: rgba(0, 0, 0, 0.1);
        }

        .area {
            stroke-width: 1;
        }

        .area.outer,
        .legend .outer {
            fill: rgba(230, 230, 255, 0.8);
            stroke: rgba(216, 216, 255, 0.8);
        }

        .area.inner,
        .legend .inner {
            fill: rgba(127, 127, 255, 0.8);
            stroke: rgba(96, 96, 255, 0.8);
        }

        .median-line,
        .legend .median-line {
            fill: none;
            stroke: #000;
            stroke-width: 3;
        }

        .legend .legend-bg {
            fill: rgba(0, 0, 0, 0.5);
            stroke: rgba(0, 0, 0, 0.5);
        }

        .marker.client .marker-bg,
        .marker.client path {
            fill: rgba(255, 127, 0, 0.8);
            stroke: rgba(255, 127, 0, 0.8);
            stroke-width: 3;
        }

        .marker.server .marker-bg,
        .marker.server path {
            fill: rgba(0, 153, 51, 0.8);
            stroke: rgba(0, 153, 51, 0.8);
            stroke-width: 3;
        }

        .marker path {
            fill: none;
        }

        .legend text,
        .marker text {
            fill: #fff;
            font-weight: bold;
        }

        .marker text {
            text-anchor: middle;
        }

        #tooltip {
            position: absolute;
            opacity: 0;
            top: -12px;
            left: 0;
            padding: 0.6em 1em;
            background: #fff;
            /* text-align: center; */
            /* border: 1px solid #ddd; */
            box-shadow: 0 6px 8px rgba(52, 73, 94, .2), 0 1px 1px rgba(52, 73, 94, 0.1);
            z-index: 10;
            transition: all 0.2s ease-out;
            pointer-events: none;
        }

        #tooltip:before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 12px;
            height: 12px;
            background: white;
            border: 1px solid #ddd;
            border-top-color: transparent;
            border-left-color: transparent;
            transform: translate(-50%, 50%) rotate(45deg);
            transform-origin: center center;
            z-index: 10;
        }

        #tooltip-date {
            margin-bottom: 0.2em;
            font-weight: 600;
        }

        .bin:hover {
            fill: #22a6b3;
        }

        .smooth-line {
            fill: none;
            stroke: darkblue;
            stroke-width: 2.5;
            z-index: 1000;
            opacity: 0.5;
        }
    </style>
    <script src='https://d3js.org/d3.v5.min.js'></script>
    <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
</head>
<body>
<div id='title'>
    <h1>History of COVID-19 in New York</h1>
    <div id='attribute-dropdown'></div>
</div>
<div id='svg-container'>
    <div id='tooltip' class='tooltip'>
        <div id='tooltip-date'></div>
        <div id='tooltip-cases'></div>
        <div id='tooltip-hospitalized'></div>
        <div id='tooltip-deaths'></div>
    </div>
</div>
<div id='brush'></div>
<div id='notes'>
    <h3>Notes:</h3>
    <p>Please see accompanying code for details.</p>
</div>

<script>

    const parseDate = d3.timeParse('%m/%d/%Y %H:%M:%S %p');
    const markers = [
        {
            'date': parseDate('03/01/2020 12:00:00 AM'),
            'label': 'First coronavirus case',
            'text': 'The first patient tests positive for coronavirus in New York after traveling abroad in Iran.',
            'dx': 10,
            'dy': 0.1

        },
        {
            'date': parseDate('03/04/2020 12:00:00 AM'),
            'label': 'Study abroad programs canceled',
            'text': 'Study abroad programs at SUNY and CUNY schools to China, Italy and other impacted counties are canceled.',
            'dx': 30,
            'dy': 0.2

        },
        {
            'date': parseDate('03/07/2020 12:00:00 AM'),
            'label': 'State of Emergency declared',
            'text': 'Gov. Andrew Cuomo declares a State of Emergency. This declaration allows, among other things, expedited procurement of essential hygiene, testing and medical supplies and expands the field of professionals permitted to conduct testing.',
            'dx': 90,
            'dy': 0.3

        },
        {
            'date': parseDate('03/18/2020 12:00:00 AM'),
            'label': 'Workforce density 50%',
            'text': 'Workforce density 50%',
            'dx': 30,
            'dy': 0.7

        },
        {
            'date': parseDate('03/19/2020 12:00:00 AM'),
            'label': 'Workforce density 25%',
            'text': 'Workforce density 25%',
            'dx': 90,
            'dy': 0.8

        },
        {
            'date': parseDate('03/22/2020 12:00:00 AM'),
            'label': 'Stay at home order',
            'text': 'Stay at home order',
            'dx': 150,
            'dy': 0.9

        },
        {
            'date': parseDate('06/08/2020 12:00:00 AM'),
            'label': 'Phase 1 reopening',
            'text': 'Phase 1 reopening',
            'dx': -10,
            'dy': 0.2

        },
        {
            'date': parseDate('06/22/2020 12:00:00 AM'),
            'label': 'Phase 2 reopening',
            'text': 'Phase 2 reopening',
            'dx': -10,
            'dy': 0.15

        },
        {
            'date': parseDate('07/06/2020 12:00:00 AM'),
            'label': 'Phase 3 reopening',
            'text': 'Phase 3 reopening',
            'dx': -10,
            'dy': 0.1

        },

    ];
    d3.csv('data/ny.csv')
        .then(function (data) {
            data.forEach(function (d) {
                d['DATE_OF_INTEREST'] = parseDate(d['DATE_OF_INTEREST']);
                d['CASE_COUNT'] = +d['CASE_COUNT'];
                d['HOSPITALIZED_COUNT'] = +d['HOSPITALIZED_COUNT'];
                d['DEATH_COUNT'] = +d['DEATH_COUNT'];
            });
            let n = 3
            let average = function average(objects, c) {
                let sum = 0;
                for (let i = 0; i < objects.length; i++) {
                    sum += objects[i][c];
                }
                return sum / objects.length;
            }
            for (let i = 0; i < data.length; i++) {
                ['CASE_COUNT', 'HOSPITALIZED_COUNT', 'DEATH_COUNT'].forEach(function (c) {
                    let avg
                    if (i < n) {
                        avg = data[i][c]
                    } else {
                        avg = average(data.slice(i - n, i), c)
                    }
                    data[i][c + '_SMOOTH'] = avg
                })

            }


            makeChart(data, markers)
        })
        .catch(function (error) {
            // handle error
        })


    function makeChart(data, markers) {
        let targetAttribute = 'CASE_COUNT';
        let barColor = 'steelblue';

        let dropdownChange = function () {
            targetAttribute = d3.select(this).property('value');
            switch (targetAttribute) {
                case 'CASE_COUNT':
                    barColor = 'steelblue'
                    break;
                case 'HOSPITALIZED_COUNT':
                    barColor = 'orange'
                    break;
                case 'DEATH_COUNT':
                    barColor = 'orangered'
                    break;
                default:
                    barColor = 'steelblue'
            }
            yScale.domain([0, d3.max(data, d => d[targetAttribute])])
            axes.select('.y').transition().call(yAxis);

            yScaleBrush.domain([0, d3.max(data, d => d[targetAttribute])])

            brushGroup.select('.brush-line')
                .transition()
                .duration(1000)
                .attr('fill', barColor)
                .attr('d',
                    d3.line(xScaleBrush, yScaleBrush)
                        .x(d => xScaleBrush(d['DATE_OF_INTEREST']))
                        .y(d => yScaleBrush(d[targetAttribute])));
            updateBars(chart.property('value'), 1000)
        };

        let attributes = ['CASE_COUNT', 'HOSPITALIZED_COUNT', 'DEATH_COUNT'];

        let dropdown = d3.select('#attribute-dropdown')
            .insert('select')
            .on('change', dropdownChange);

        dropdown.selectAll('option')
            .data(attributes)
            .enter().append('option')
            .attr('value', function (d) {
                return d;
            })
            .text(function (d) {
                return d.replace('_', ' ').toLowerCase();
            });

        const svgWidth = 1728,
            svgHeight = 972,
            margin = {top: 130, right: 20, bottom: 70, left: 70},
            chartWidth = svgWidth - margin.left - margin.right,
            chartHeight = svgHeight - margin.top - margin.bottom,
            brushAreaHeight = 100,
            totalAnimationTime = 15000;
        const xScale = d3.scaleTime()
                .range([0, chartWidth])
                .domain(d3.extent(data, d => d['DATE_OF_INTEREST']))
                .nice(d3.timeDay),
            yScale = d3.scaleLinear().range([chartHeight, 0])
                .domain([0, d3.max(data, d => d[targetAttribute])]),
            dateToIdx = d3.scaleTime()
                .range([0, data.length])
                .domain(d3.extent(data, d => d['DATE_OF_INTEREST'])),
            xScaleBrush = xScale.copy(),
            yScaleBrush = yScale.copy().range([brushAreaHeight, 0]);
        const xAxis = d3.axisBottom(xScale),
            // .ticks(d3.timeDay.every(1)),
            yAxis = d3.axisLeft(yScale);

        let svg = d3.select('#svg-container').append('svg')
            .attr('width', svgWidth)
            .attr('height', svgHeight);
        const chart = svg
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        chart.append('g').attr('class', 'bars');
        //AXES
        const axes = chart.append('g');

        axes.append('g')
            .attr('class', 'x axis')
            .attr('transform', 'translate(0,' + chartHeight + ')')
            .call(xAxis)
            .selectAll('text')
            .style('text-anchor', 'end')
            .attr('dx', '-.8em')
            .attr('dy', '.15em')
            .attr('transform', 'rotate(-90)');

        axes.append('text')
            .attr('transform',
                'translate(' + (chartWidth / 2) + ' ,' +
                (chartHeight + margin.top + 40) + ')')
            .style('text-anchor', 'middle')
            .text('Date');

        axes.append('g')
            .attr('class', 'y axis')
            .call(yAxis);

        axes.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', 0 - margin.left)
            .attr('x', 0 - (chartHeight / 2))
            .attr('dy', '1em')
            .style('text-anchor', 'middle')
            .text(targetAttribute.replace('_', ' '));

        chart.append('g')
            .append('path')
            .datum(data)
            .attr('class', 'smooth-line')
            .attr('d', d3.line()
                .x(d => xScale(d['DATE_OF_INTEREST']))
                .y(d => yScale(d[targetAttribute + '_SMOOTH']))
            )

        //BRUSH
        let focusTopMargin = 20;

        const brush = d3.brushX()
            .extent([[0, 0], [chartWidth, brushAreaHeight]])
            .on('brush', brushed)
            .on('end', brushended);

        const defaultSelection = [xScaleBrush.range()[0], xScaleBrush(d3.timeMonth.offset(xScale.domain()[0], 1))];

        let brushGroup = svg.append('g')
            .attr('class', 'brush')
            .attr('transform', 'translate(' + margin.left + ',' + focusTopMargin + ')');
        brushGroup.call(d3.axisTop(xScaleBrush), xScaleBrush, brushAreaHeight);

        brushGroup.append('path')
            .datum(data)
            .attr('class', 'brush-line')
            .attr('fill', barColor)
            .attr('d',
                d3.line(xScaleBrush, yScaleBrush)
                    .x(d => xScaleBrush(d['DATE_OF_INTEREST']))
                    .y(d => yScaleBrush(d[targetAttribute])));

        const gb = brushGroup
            .call(brush)
            .call(brush.move, [xScaleBrush.range()[0], xScaleBrush(d3.timeDay.offset(xScale.domain()[0], 1))]);

        brushGroup
            .transition()
            .ease(d3.easePolyOut.exponent(0.3))
            .duration(totalAnimationTime)
            .call(brush.move, [xScaleBrush.range()[0], xScaleBrush.range()[1]]);

        let makeAnnotations = d3.annotation();

        function updateBars(brushSelection, duration) {
            xScale.domain(d3.event.selection === null ? xScaleBrush.domain() : brushSelection);
            chart.select('.x.axis').call(xAxis);
            let filteredData = data.filter(d => d['DATE_OF_INTEREST'] > brushSelection[0] & d['DATE_OF_INTEREST'] < brushSelection[1]);
            let filteredMarkers = markers.filter(d => d['date'] > brushSelection[0] & d['date'] < brushSelection[1])

            let u = d3.select('.bars').selectAll('.bin').data(filteredData);

            u.enter()
                .append('rect')
                .merge(u)
                .attr('fill', barColor)
                .attr('x', d => xScale(d['DATE_OF_INTEREST']))
                .attr('width', chartWidth / filteredData.length)
                .attr('y', chartHeight)
                .attr('height', 0)
                .classed('bin', 1)
                .transition()
                .duration(duration)
                .attr('y', d => yScale(d[targetAttribute]))
                .attr('height', d => chartHeight - yScale(d[targetAttribute]))

            chart.selectAll('.bin')
                .on('mouseenter', onMouseEnter)
                .on('mouseleave', onMouseLeave);
            u.exit().remove();

            chart.select('.smooth-line')
                .datum(filteredData)
                .transition()
                .duration(duration === 100 ? duration / 2 : duration)
                .attr('d', d3.line()
                    .x(d => xScale(d['DATE_OF_INTEREST']) + (chartWidth / filteredData.length) / 2)
                    .y(d => yScale(d[targetAttribute + '_SMOOTH']))
                )

            let annotations = filteredMarkers.map(m => ({
                'note': {
                    //'label': m.text,
                    'title': m.label
                },
                connector: {
                    end: "dot"
                },
                'x': xScale(m.date) + (chartWidth / filteredData.length) / 2,
                'y': chartHeight,
                'dy': -chartHeight * m.dy,
                'dx': m.dx,
                'color': 'MediumVioletRed'
            }));
            if (annotations.length > 0) {
                let makersGroup = chart.select(".markers");
                if (makersGroup.empty()) {
                    makeAnnotations.annotations(annotations)
                    chart.append("g")
                        .attr('class', 'markers')
                        .call(makeAnnotations)
                } else {
                    makeAnnotations.annotations(annotations);
                    makeAnnotations.update()
                }

            }
        }

        function brushed() {
            if (d3.event.selection) {
                let brushSelection = d3.event.selection.map(xScaleBrush.invert, xScaleBrush).map(d3.timeDay.round);
                chart.property('value', brushSelection);
                updateBars(brushSelection, 100);
            }
        }

        function brushended() {
            if (!d3.event.selection) {
                gb.call(brush.move, defaultSelection);
            }
        }

        //TOOLTIP
        const tooltip = d3.select('#tooltip');
        let timeFormat = d3.timeFormat('%B %d, %Y');

        function onMouseEnter(datum) {
            tooltip.select('#tooltip-date').text(timeFormat(datum['DATE_OF_INTEREST']));
            tooltip.select('#tooltip-cases').text(['Number of cases:', datum['CASE_COUNT']].join(' '));
            tooltip.select('#tooltip-hospitalized').text(['Number of hospitalized:', datum['HOSPITALIZED_COUNT']].join(' '));
            tooltip.select('#tooltip-deaths').text(['Number of deaths:', datum['DEATH_COUNT']].join(' '));
            const x = xScale(datum['DATE_OF_INTEREST']) + margin.left + (chartWidth / data.length) / 2
            const y = yScale(datum[targetAttribute]) + margin.top
            tooltip.style('transform', `translate(`
                + `calc( -50% + ${x}px),`
                + `calc(-100% + ${y}px)`
                + `)`)
            tooltip.style('opacity', 1);
        }

        function onMouseLeave() {
            tooltip.style('opacity', 0)
        }
    }

</script>

</body>
</html>
